# Псевдокоманды

**Псевдокоманды управляют работой самого компилятора, а не процессора**

## DB, DW, DD - определение констант

    db 0x55 ; Определяет байт
    db 0x55, 0x56, 0x57 ; Определяет последовательность байт
    db 'a', 0x55 ; два байта - код символа, и 0x55
    db 'Hello' ; последовательность байт - строка
    
    dw 0x1234 ; определяет слово (0x34, 0x12)
    dw 'a'    ; 0x61, 0x00 
    
    dd 0x12345678 ; 0x78, 0x56, 0x34, 0x12
    
    number dd 0x1 ; переменная number со значением 1
    
## RESB, RESW, RESD - объявление переменных

Эти команды резервируют определенное количество памяти, но не инициализируют ее.

    resb 1 ; резервирует 1 байт
    
    resw 4 ; резервирует 4 слова
    
    resd 60 ; резервирует 60 двойных слов
    
    number resd 1 ; переменная number размеров в слово
    
## TIMES - повторение следующей псевдокоманды

Директива TIMES - это псевдокоманда префиксного типа, то есть она используется только в паре с другой псевдокомандой. Она повторяет последующую команду указанное кол-во раз. 

    times 5 inc eax ; 5 раз выполнить INC EAX
    
## INCBIN - подключение двоичного файла

    incbin "sound.wav" ; подключаем весь файл
    incbin "sound.wav", 512 ; пропускаем 512 байт от начала
    incbin "sound.wav", 512, 80 ; пропускаем первые 512 байт и последние 80
    
## EQU - вычисление константных выражений

    FOUR EQU 4
    
## SEG - смена сегмента

При создании больших программ для реального режима процессора нам нужно использовать для кода и данных несколько сегментов, чтобы обойти проблему 16-битной адресации. Пока будем считать, что сегмент - это часть адреса переменной. 

с помощью оператора SEG в сегментный регистр может быть загружен адрес сегмента, где физически расположена переменная:

    mov ax, seg counter ; поместить в AX фдрес сегмента, где
                        ; размещена переменная counter
    mov es, ax          ; поместить этот адрес в сегментный регистр
                        ; это можно сделать только косвенно
    mov bx, counter     ; загрузить в BX адрес (смещение) 
                        ; переменной counter. Теперь пара ES:BX
                        ; содержит полный адрес переменной counter
    mov cs, es:[bx]     ; копировать значение переменной
                        ; в регистр CX
                        
## ALIGN - выравнивание данных в памяти

Мы знаем, что процессоры работают с регистрами на порядок быстрее, чем с операндами, расположенными в памяти. Поэтому желательно выполнять все вычисления в регистрах, сохраняя в памяти только результат.

При обработке больших массивов частые обращения к памяти неизбежны. Скорость доступа к памяти можно увеличить, если размещать данные по адресам, кратным степени двойки. Дело в том, что между памятью и процессором имеется система буферов памяти, недоступная программисту. Эти буферы содержат блоки чаще всего используемых данных из основной памяти или несохраненные данные. Выравнивание данных по некоторым адресам освобождает буферы, поэтому данные обрабатываются быстрее.

К сожалению, каждый тип процессора предпочитает свой тип выравнивания. Мы можем сообщить компилятору требуемый тип директивой ALIGN. Ее аргумент - то число, по адресам, кратным которому, требуется размещать данные:

    align 4  ; размещать данные по адресам, кратным 4
    align 16 ; размещать данные по адресам, кратным 16
    
