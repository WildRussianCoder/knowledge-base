# select()

Системный вызов `select()` обеспечивает механизм для реализавции синхронного мультиплексного ввода-вывода:

    #include <sys/select.h>

    int select (
        int n,
        fd_set* readfds,
        fd_set* writefds,
        fd_set* exceptfds,
        struct timeval* timeout
    );

    FD_CLR (int fd, fs_set* set);
    FD_ISSET (int fd, fd_set* set);
    FD_SET (int fd, fd_set* set);
    FD_ZERO (fd_set* set);

Вызов к `select()` блокируется, пока указанные файловые дескрипторы не будут готовы к выполнению ввода-вывода, либо пока не истечет необязательный интервал задержки.

Отслеживаемые файловые дескрипторы делятся на три группы. Дескрипторы из каждой группы дожидаются событий определенного типа. 

Файловые дескрипторы, перечисленные в `readfds`, отслеживают, не появились ли данные, доступные для чтения, то есть они проверяют, удастся ли совершить операцию считывания без блокировки. 

Файловые дескрипторы перечисленные в группе `writefds`, аналогичным образом дожидаются возможности совершить неблокирующую операцию записи.

Файловые дескрипторы из группы `exceptfds` следят, ну было ли исключения, либо не появлись ли в доступе внеполосные данные (в таком состоянии могут находиться только сокеты). 

Одна из групп может иметь значение `NULL`, это означает, что `select()` не отслеживает события данного вида.

При успешном возврате каждая группа изменяется таким образом, что в ней остаются только дескрипторы, готовые к вводу-выводу определенного типа, соответствующего конкретной группе. 

Первый парметр, `n`, равен наивысшему значению файлового дескриптора, присутствующему во всех группах, плюс 1. Следовательно, сторона, вызывающая `select()`, должна проверить, какой из заданных файловых дескриптором имеет наивысшее значение, а затем передать сумму (это значение плюс 1) первому параметру.

Параметр `timeout` является указателем на структуру `timeval`, определяемую следующим образом:

    #include <sys/time.h>

    struct timeval {
        long tv_sec; // секунды
        long tv_usec; // микросекунды
    }

Если этот пармаметр не равер `NULL`, то вызов `slect()` вернется через `tv_sec` секунд и `tv_usec` микросекунд, даже если ни один из файловых дескрипторов не будет готов к вводу-выводу. 

Манипуляции с файловыми дескрипторами осуществляются не напрямую, а посредством вспомогательных макрокоманд. Благодаря этому системы UNIX могут реализовывать группы дескрипторов так, как считается целесообразным. В большинстве систем, однако, эти группы реализованы как простые битовые массивы.

`FD_ZERO` удаляет все файловые дескрипторы из указанной группы. Эта команда должна вызываться перед каждой активизацией `select()`:

    fd_set writefds;

    FD_ZERO(&writefds);

`FD_SET` добавляет дескриптор в указанную группу, а `FD_CLR` удаляет дескриптор из указанной группы:

    FD_SET(fd, &writefds);
    FD_CLR(fd, &writefds);

`FD_ISSET` проверяет, принадлежит ли определенный файловый дескриптор к конкретной группе. Используется после возврата вызова от `select()`. С его помощью можно проверить, готов ли определенный файловый дескриптор к действию:

    if(FD_ISSET (fd, &readfds)){
        // что-то делаем
    }

Группы файловых дескрипторов создаются в статическом режиме, поэтому устанавливается лимит на максимальное количество дескрипторов, которые могут находиться в группах. Кроме того, задается максимальное значение, которое может иметь какой-либо из этих дескрипторов. Оба значения определяются командой `FD_SETSIZE`. В Linux данное значение равно `1024`.

По истичению времени `select()` возвращает `0`, в слусае ошибки - `-1`, в случае успеха - любое положительное ненулевое значение.

**Для расширения кругозора можно прочитать еще про `pselect()`**