# Ожидание завершенных дочерних процессов

Ядро Linux предоставляет несколько интерфейсов для получения информации о завершенном дочернем процессе. Самый просто из них, определенный POSIX, называется `wait()`:

    #include <sys/types.h>
    #include <sys/wait.h>
    
    pid_t wait(int* status);
    
Вызов `wait()` возвращает pid завершенного дочернего процесса или `-1` и `errno` в случае ошибки. Если никакого дочернего процессак не было прервано, вызов блокируется, пока потомок не завершится. Если дочерний процесс уже был завершен, вызов возвращает результаты немедленно. Следовательно, если вызвать `wait()` сразу после сообщения о завершении дочернего процесса, результат будет немедленно выдан без блокировки.

Если указатель `status` не `NULL`, то там находится дополнительная информация о дочернем процессе. POSIX позволяет при реализации определение битов статуса разработчиками самостоятельно, поэтому стандарт предусматривает семейство макросов для интерпретации параметра:

    #include <sys/wait.h>
    
    int WIFEXITED(status); // если завершен через _exit()
    int WIFSIGNALED(status); // если завершен через сигнал
    int WIFSTOPPED(status); // если процесс был остановлен
    int WIFCONTINUED(status); // процесс был продолжен
    
    int WEXITSTATUS(status); // код завершения
    int WTERMSIG(status); // номер сигнала, который вызвал прерывание
    int WSTOPSIG(status);
    int WCOREDUMP(status); // true, если процессор сбросил ядро в ответ на получение сигнала
    
## Ожидание определенного процесса

Если вам известен pid процесса, завершения которого вы ждете, можно использовать системный вызов `waitpid()`:

    #include <sys/types.h>
    #include <sysy/wait.h>
    
    pid_t waitpid(pid_t pid, int* status, int options);
    
Вызов `waitpid()` - болеее можщная версия `wait()`. Его дополнительные параметры позволяют более тонко его настроить.

Параметр `pid` точно определяет, какой процесс или процессы нужно ожидать. Его значения могут попадать в четыре промежутка:
* `< -1` - ожидание любого дочернего процесса, чей ID группы процессов равен модулю этой величины
* `-1` - ожидание любого дочернего процесса
* `0` - ожидание любого дочернего процесса, принадлежащего той же группе процессов, что и вызывающий
* `> 0` - ожидание любого дочернего процесса, чей pid в точности равен указанной величине

Параметр `status` работает аналогично таковому в системном вызове `wait()` и может быть обработан с помощью макросов, описанных выше.

Параметр `options` может передавать следующие значения с помощью логического ИЛИ либо пустое множество:
* `WNOHANG` - не блокировать вызов, немедленно вернуть результат, если ни один подходящий процесс еще не завершился
* `WUNTRACED` - при его выборе устанавливается параметр `WIFSTOPPED`, даже если вызывающий процесс не отслеживает свой дочерний; это свойство помогает реализовать более общее управление заданиями, как это сделано в оболочке
* `WCONTINUED` - если установлен, то бит `WIFCONTINUED` в возвращаемом параметре статуса будет установлен, даже если вызывающий процесс не отслеживает свой дочерний

В случае успеха `waitpid()` возвращает pid процесса, статус которого изменился. Если установлен `WNOHANG`, а указанный дочерний процесс (один или несколько) не изменил свой статус, `waitpid()` вернет `0`. в Случае ошибки вызов возвращает `-1` и `errno`.

## Еще больше гибкости при ожидании

    #include <sys/wait.h>
    
    int waitid(idtype_t idtype, id_t id, siginfo_t* infop, int options);
    
Как `wait()` и `waitpid()`, системный вызов `waitid()` используется для ожидания и получения информации об измененном статусе (заверешение, остановки, продолжение) дочернего процесса. Он предоставляет еще больше параметров, но их использование несколько сложнее.

Аналогично `waitpid()` с помощью `waitid()` разработчик может выбрать ожидаемый процесс. Однако `waitid()` требует для этого указания не одного, а двух параметром. С помощью аргументов `idtype` и `id` определяется, какой дочерний процесс нужно ожидать.

Значения `idtype` могут быть следующими:
* `P_PID` - ожидание дочернего процесса, pid которого совпадает со значением `id`
* `P_GID` - ожидание дочернего процесса, идентификатор группы которого совпадает со значением `id`
* `P_ALL` - ожидане всех дочерних процессов, `id` игнорируется 

В параметре `options` могут быть указаны одно или несколько из следующих значений с помощью двоичного ИЛИ:
* `WEXITED` - вызов будет ждать дочерних процессов, которые завершились
* `WSTOPPED` - вызов будет ожидать дочерних процессов, которые остановили выполнение в ответ на получение сигнала
* `WCONTINUED` - вызов будет ожидать дочерних процессов, которые продолжили выполнение в ответ на получение сигнала
* `WNOHANG` - вызов не может быть забокирован и верент результаты немедленно, если но один из указанных дочерних процессов еще не завершен 
* `WNOWAIT` - вызов не будет выводить указанный процесс из статуса зомби; этот процесс будет обработан в будущем

В случае успеха `waitid()` возвращает параметр `infop`, который укажет на допустимый тип `siginfo_t`. Точная структура `siginfo_t` зависит от реализации, но после выполнения `waitid()` заполненными остаются лишь несколько полей. Таким образом, при успешном вызове допустимые значения будут содержаться в следующих полях:
* `si_pid` - pid дочернего процесса
* `si_uid` - uid дочернего процесса
* `si_code` - может принимать значения `CLD_EXITED`, `CLD_KILLED`, `CLD_STOPPED` или `CLD_CONTINUED` в результате завершения дочернего процесса, окончания или продолжения его по сигналу соответственно
* `si_signo` - устанавливается значение `SIGCHLD`
* `si_status` - если `si_code` устанавился равнм `CLD_EXITED`, это поле содержит код выхода дочернего процесса, и наоборот, это поле принимает значение номера сигнала, отправленного дочернему процессу и вызвавшего изменения

В случае спеха - `0`, иначе - `-1` и `errno`.

**функции wait3() и wait4() стоит рассмотреть для просвещения**