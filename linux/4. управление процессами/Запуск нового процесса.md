# Запуск нового процесса

## Семейство вызовов exec

Единой функции `exec` не существует, на одном системном вызове построено целое семейство таких функций. Самый простой из этих вызовов `execl()`:

    #include <unistd.h>
    
    int execl(const char* path, const char* arg, ...);
    
Вызов `execl()` замещает текущий образ процесса новым, загружая в память программу, определенную `path`. Параметр `arg` - первый параметр. Многоточие означает переменное количество параметров. Список аргументов должен обязательно завершаться `NULL`.

В случае ошибки - `-1` и `errno`.

В случае успешного выполнения вызов `execl()` изменяет не только адресное пространство и образ процесса, но и некоторые другие атрибуты процесса:
* любые ожидающие сигналы исчезают
* любые сигналы, отлавливаемые процессом, возвращаются к своему поведению по умолчанию, поскольку обработчиков сигналов больше нет в процессном адресном пространстве
* все блокировки памяти удаляются 
* большинство атрибутов потока возвращаются к значениям по умолчанию
* большая часть статистических данных процесса сбрасывается
* все адресное пространство памяти, относящееся к данному процессу, включая загруженные файлы, очищается
* все, находящееся исключительно в пользовательском пространстве, включая функциональные библиотеки C, напримерповедение `atexit()`, удаляется. 

Некоторые свойства процесса, однако, не изменяются. Например, идентификатор (свой и родительский), приоритет, а также пользователь и группа остаются теми же.

### Остальная часть семейства

Кроме `execl()`, в семействе есть еще пять членов:

    #include <unistd.h>
    
    int execlp(const char* path, const char* arg, ...);
    int execle(const char* path, const char* arg, ..., char* const envp[]);
    int execv(const char* path, char* const argv[]);
    int execvp(const char* file, char* const argv[]);
    int execve(const char* filename, char* const argv[], char* const envp[]);
    
Запомнить все очень просто, `l` и `v` указывают, передаются ли аргументы списком или массивомж Символ `p` указывает, что система будет искать указанный файл по полному пользовательскому пути. В командах, где используются варианты с `p`, можно указать только имя файла, если он находится в пределах пользовательского пути. Наконец, `e` обозначает, что для нового процесса создается новое окружение. Интересно, что, хотя технических ограничений для этого не существует, в семействе `exec` нет элемента, возволяющего и искать путь к файлам, и создавать новое окружение. Возможно, это объясняется тем, что варианты `p` предназаначены для использования оболочками, а процессы, исполняемые в оболочках, как правило, наследуют свое окружение от них.

## Системный вызов fork()

Новый процесс, запускающий тот же системный образ, что и текущий, может быть создан с помощью системного вызова `fork()`:

    #include <sys/types.h>
    #include <unistd.h>
    
    pid_t fork();
    
В случае успешного обращения к `fork()` создается новый процесс, во всех отношениях идентичный вызывающему. Оба процесса выполняются от точки обращения к `fork()`, как будто ничего не происходило.

Новый процесс является дочерним по отношению к вызывающему, который, в свою очередь, называется родительским. В дочернем процессе успешный запуск `fork()` возвращает `0`. В родительском `fork()` возвращает pid дочернего. Родительский и дочерний процессы практически идентичны, за исключением некоторых особенностей:
* pid дочернего процесса, конечно, назначется заново и отличается от родительского
* родительский pid дочернего процесса установлен равным pid родительского процесса 
* ресурсная статистика дочернего процесса обнуляется
* любые ожидающие сигналы прерываются и не наследуются дочерним процессом
* никакие вовлеченные блокировки файлов не наследуются дочерним процессом

В случае ошибки - `-1` и `errno`.

Чаще всего системный вызов `fork()` используется для создания нового процесса и последующей загрузки в него нового двоичного образа. 

### vfork()

    #include <sys/types.h>
    #include <unistd.h>
    
    pid_t vfork();
    
Успешное исполненые `vfork()` работает так же, как и `fork()`, кроме того, что дочерний процесс должен немедленно вызвать одну из функций `exec` или завершиться, вызвав `_exit()`.

`vfork()` считается устаревшим и не рекомендуется к использованию, хотя и работает быстрее `fork()`.

