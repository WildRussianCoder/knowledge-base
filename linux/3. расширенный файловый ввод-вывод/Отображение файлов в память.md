# Отображение файлов в память

## mmap()

При вызове `mmap()` мы указываем ядру отобразить в память `len` байт объекта, представленного файловым дескриптором `fd` и начинающийся в файле со смещения в `offset` байт. Если включить `addr`, то данное значение указвывает адрес в памяти, который имеет приоритет при выборе начальной точки отображения. Права доступа регламентируются в `prot`, а дополнительное поведение можно определить с помощью `flags`:

    #include <sys/mman.h>

    void* mmap(void* addr, size_t len, int prot, int flags, int fd, off_t offset);

Возможные значения `prot`:
* `PROT_NONE` - почти не применяется. Запрещает отображение уже существующих отображений
* `PROT_READ` - страницы доступны для чтения
* `PROT_WRITE` - страницы доступны для записи
* `PROT_EXEC` - страницы доступны для выполнения

Возможные значения `flags`:
* `MAP_FIXED` - показывает `mmap()` считать `addr` обязательным, а не рекомендательным.
* `MAP_PRIVATE` - указывает, что отбражение не может использовать совместно.
* `MAP_SHARED` - процесс использует отображение совместно со всеми другими процессами, отображающими тот же файл. Запись в отображение эквивалентна записи в файл. Считывание из отображения будет учитывать записи, сделанные другими процессами. 

В случае успеха вызов `mmap()` возвращает расположение отображаемой области. При ошибке он возвращает `MAP_FAILED` и устанавливает `errno`.

## sysconf()

Стандартный метод получения размера страницы, определяемый в POSIX, называется `sysconf()`:

    #include <unistd.h>

    long sysconf(int name);

Метод `sysconf()` возвращает значение конфигурационного элемента `name` либо значение `-1`, если элемент `name` невалиден. 

Чтобы узнать развер страницы необходимо указать `_SC_PAGE_SIZE` или `_SC_PAGESIZE`.

## getpagesize()

Linux также предоставялет функцию:

    #include <unistd.h>

    int getpagesize();

## Макрос PAGE_SIZE

Размер страницы также статически сохраняется в макросе `PAGE_SIZE`, определяемом в `<sys/user.h>`.

## munmap()

В Linux есть вызов `munmap()`, позволяющий удалять отображение, созданное при вызове `mmap()`:

    #include <sys/mman.h>

    int munmap(void* addr, size_t len);

Вызов удаляет все отображения, в которых содержатся страницы, расположенные в любой части адресного пространства процесса, начинающейся с `addr`(здесь должна начинаться страница) и на протяжении `len` байт. Как только отображение удалено, область памяти, которая была с ним ассоциирована, больше не является допустимой и при следующих попытках обращения к ней генерируется сигнал `SIGSEGV`.

При успехе - `0`, при ошибке - `-1` и `errno`.

## Изменение размеров отображения

Linux предоставляет системный вызов `mremap()`, позволяющий увеличивать или уменьшать размер заданного отображения. Эта функция специфична для Linux:

    #define _GNU_SOURCE

    #include <sys/mman.h>

    void* mremap(void* addr, size_t old_size, size_t new_size, unsigned long flags);

Вызов `mremap()` расширяет или сужает площадь отображения в области памяти [addr, addr+old_size], устанавливая новое значение `new_size`. 

Параметр `flags` может иметь значение `0` или `MREMAP_MAYMOVE`. Второе значение указывает, что при необходимости ядро может переместить область отображения, если это нужно для изменения размера.

## Изменение защиты отображения 

    #include <sys/mman.h>

    int mprotect(const void* addr, size_t len, int prot);

## Синхронизация файла с помощью отображения 

    #include <sys/mman.h>

    int msync(void* addr, size_t len, int flags);

Возможные значения `flags`:
* `MS_SYNC` - синхронная синхронизация
* `MS_ASYNC` - асинхронная синхронизация
* `MS_INVALIDATE` - все другие копии отображения станут недействительными

## Извещения об отображении

В Linux предоставляется системный вызов `madvise()`, с помощью которого процессы могут извещать ядро или подсказывать ему, как предполагается использовать данное отображение. На основании этой информацииядро может оптимизировать поведение, чтобы пользоваться преимуществами конкретного варианта отображения. Конечно, ядро Linux динамически корректирует свое поведение и, как правило, обеспечивает оптимальную производительность без явных извещений такого рода. Тем не менее, давая подсказки, мы можем добиться желаемого кэширования и опережающего считывания при некоторых типах нагрузки.

Вызов `madvise()` сообщает ядру, как следует обращаться со страницами, находящимися в памяти по адресу `addr` и далее до `len` байт:

    #include <sys/mman.h>
    
    int madvise(void* addr, size_t len, int advince);
    
Если `len` равно `0`, то ядро применит рекомендацию ко всей области отображения, начиная с `addr`. Параметр `advice` ограничивает область действия рекомендации и может иметь одно из следующих значений:

* `MADV_NORMAL` - приложение не получает конкретной рекомендации, как работать с данной областью памяти
* `MADV_RANDOM` - приложение планирует обращаться к страницам из указанного диапазона в случайном порядке
* `MADV_SWQUENTIAL` - приложение будет обращаться к страницам из указанного диапазона последовательно, от самого нижнего до самого верхнего адреса
* `MADV_WILLNEED` - ядро инициирует опережающее считывание, копируя указанные страницы в память
* `MADV_DONTNEED` - ядро высвобождает все ресурсы, связанные с указанными страницами в памяти, а также сбрасывает все грязные и еще не синхронизированные страницы; при последующих обращениях к отображенным данным эта информация будет подкачиваться из файла с резервной копией или (при анонимных отображениях) заполнять нулями запрошенные страницы
* `MADV_DONTFORK` - указанные здесь страницы не копируются в дочерний процесс на протяжении всего ветвления
* `MADV_DOFORK+` - отменяет поведение `MADV_DONTFORK`

В случае успеха `madvise()` возвращает `0`. При ошибке - `-1` и `errno`.
